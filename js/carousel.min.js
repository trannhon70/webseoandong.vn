const track = document.querySelector('.carousel-track');
        const items = document.querySelectorAll('.carousel-item');
        const prevBtn = document.querySelector('.carousel-prev');
        const nextBtn = document.querySelector('.carousel-next');

        // Clone c√°c item ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng v√¥ h·∫°n
        const cloneItems = () => {
            Array.from(items).slice(0, 4).forEach(item => {
                track.appendChild(item.cloneNode(true));
            });
            Array.from(items).slice(-4).forEach(item => {
                track.insertBefore(item.cloneNode(true), track.firstChild);
            });
        };

        cloneItems(); // Th·ª±c hi·ªán clone

        // C·∫≠p nh·∫≠t danh s√°ch items sau khi clone
        const allItems = document.querySelectorAll('.carousel-item');
        const visibleItems = 4; // S·ªë l∆∞·ª£ng item hi·ªÉn th·ªã c√πng l√∫c
        let currentIndex = visibleItems; // B·∫Øt ƒë·∫ßu t·ª´ item g·ªëc ƒë·∫ßu ti√™n
        const itemWidth = 100 / visibleItems;
        track.style.width = `${allItems.length * (25 / visibleItems)}%`;

        const updateCarousel = (transition = true) => {
            track.style.transition = transition ? 'transform 0.3s ease-out' : 'none';
            track.style.transform = `translateX(-${currentIndex * itemWidth}%)`;
        };

        // X·ª≠ l√Ω reset v·ªã tr√≠ khi ƒëi ƒë·∫øn clone items
        track.addEventListener('transitionend', () => {
            if (currentIndex <= visibleItems - 1) {
                currentIndex = allItems.length - visibleItems * 2;
                updateCarousel(false);
            } else if (currentIndex >= allItems.length - visibleItems) {
                currentIndex = visibleItems;
                updateCarousel(false);
            }
        });

        // X·ª≠ l√Ω n√∫t ƒëi·ªÅu h∆∞·ªõng
        prevBtn.addEventListener('click', () => {
            currentIndex--;
            updateCarousel();
        });

        nextBtn.addEventListener('click', () => {
            currentIndex++;
            updateCarousel();
        });

        // üñ±Ô∏è K√©o chu·ªôt ƒë·ªÉ di chuy·ªÉn
        let isDragging = false;
        let startX = 0;
        let currentTranslate = 0;
        let prevTranslate = 0;
        let velocity = 0;
        let animationFrame;

        const onDragStart = (e) => {
            isDragging = true;
            startX = e.pageX || e.touches[0].pageX;
            prevTranslate = currentIndex * itemWidth;
            velocity = 0;
            track.style.transition = 'none';

            animationFrame = requestAnimationFrame(smoothDrag);
        };

        const onDragMove = (e) => {
            if (!isDragging) return;

            const currentX = e.pageX || e.touches[0].pageX;
            const deltaX = (startX - currentX) / track.offsetWidth * 100; // Chuy·ªÉn ƒë·ªïi px sang %
            velocity = deltaX - (prevTranslate - currentTranslate); // T√≠nh t·ªëc ƒë·ªô
            currentTranslate = prevTranslate + deltaX;

            track.style.transform = `translateX(-${currentTranslate}%)`;
        };

        const onDragEnd = () => {
            if (!isDragging) return;
            isDragging = false;
            cancelAnimationFrame(animationFrame);

            // X√°c ƒë·ªãnh item g·∫ßn nh·∫•t theo t·ªëc ƒë·ªô k√©o
            if (velocity > 1) {
                currentIndex++;
            } else if (velocity < -1) {
                currentIndex--;
            } else {
                const movedBy = prevTranslate - currentTranslate;
                if (movedBy > itemWidth / 3) {
                    currentIndex++;
                } else if (movedBy < -itemWidth / 3) {
                    currentIndex--;
                }
            }

            updateCarousel();
        };

        // C·∫≠p nh·∫≠t v·ªã tr√≠ li√™n t·ª•c khi k√©o
        const smoothDrag = () => {
            if (isDragging) {
                track.style.transform = `translateX(-${currentTranslate}%)`;
                requestAnimationFrame(smoothDrag);
            }
        };

        // Ch·ªâ k√©o khi click gi·ªØ chu·ªôt
        track.addEventListener('mousedown', onDragStart);
        track.addEventListener('mousemove', onDragMove);
        track.addEventListener('mouseup', onDragEnd);
        track.addEventListener('mouseleave', onDragEnd);

        // H·ªó tr·ª£ k√©o tr√™n mobile (ch·∫°m v√†o ƒë·ªÉ k√©o)
        track.addEventListener('touchstart', onDragStart);
        track.addEventListener('touchmove', onDragMove);
        track.addEventListener('touchend', onDragEnd);

        // Kh·ªüi t·∫°o v·ªã tr√≠ ban ƒë·∫ßu
        updateCarousel(false);

        // T·ª± ƒë·ªông chuy·ªÉn slide m·ªói 3 gi√¢y
let autoplayInterval = setInterval(() => {
    currentIndex++;
    updateCarousel();
}, 3000);

// D·ª´ng autoplay khi ng∆∞·ªùi d√πng t∆∞∆°ng t√°c
const stopAutoplay = () => {
    clearInterval(autoplayInterval);
    autoplayInterval = null;
};

// Kh·ªüi ƒë·ªông l·∫°i autoplay sau khi ng∆∞·ªùi d√πng t∆∞∆°ng t√°c
const restartAutoplay = () => {
    if (!autoplayInterval) {
        autoplayInterval = setInterval(() => {
            currentIndex++;
            updateCarousel();
        }, 3000);
    }
};

// G√°n s·ª± ki·ªán d·ª´ng autoplay khi ng∆∞·ªùi d√πng nh·∫•n n√∫t ho·∫∑c k√©o
prevBtn.addEventListener('click', stopAutoplay);
nextBtn.addEventListener('click', stopAutoplay);
track.addEventListener('mousedown', stopAutoplay);
track.addEventListener('touchstart', stopAutoplay);

// Kh·ªüi ƒë·ªông l·∫°i autoplay khi ng∆∞·ªùi d√πng r·ªùi tay kh·ªèi chu·ªôt
track.addEventListener('mouseup', restartAutoplay);
track.addEventListener('mouseleave', restartAutoplay);
track.addEventListener('touchend', restartAutoplay);
